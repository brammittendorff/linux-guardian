use crate::models::Finding;
use anyhow::{Context, Result};
use sha2::{Digest, Sha256};
use std::collections::HashSet;
use std::fs;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::process::Command;
use tracing::{debug, info, warn};

/// MalwareBazaar CSV export URL (free, no API key required)
const MALWARE_BAZAAR_URL: &str = "https://bazaar.abuse.ch/export/csv/full/";

/// Local cache directory for malware hash database
const CACHE_DIR: &str = "/var/cache/linux-guardian";
const HASH_DB_FILE: &str = "malware_hashes.csv";

/// Maximum file size to scan (100MB) - larger files are unlikely to be malware binaries
const MAX_FILE_SIZE: u64 = 100 * 1024 * 1024;

/// Malware hash database
#[derive(Debug, Clone)]
struct MalwareHashDatabase {
    sha256_hashes: HashSet<String>,
    total_count: usize,
}

/// Check executables against malware hash database (fast mode - high risk only)
pub async fn check_malware_hashes_fast(deep_scan: bool) -> Result<Vec<Finding>> {
    check_malware_hashes_with_paths(
        &[
            "/tmp",     // Temporary files (highest risk)
            "/var/tmp", // Persistent temp (highest risk)
            "/dev/shm", // Shared memory (highest risk)
        ],
        deep_scan,
    )
    .await
}

/// Check executables against malware hash database (comprehensive mode)
pub async fn check_malware_hashes_comprehensive(deep_scan: bool) -> Result<Vec<Finding>> {
    check_malware_hashes_with_paths(
        &[
            "/tmp",
            "/var/tmp",
            "/dev/shm",
            "/home",          // All user home directories
            "/root",          // Root user home
            "/usr/local/bin", // Locally installed programs
            "/usr/local/sbin",
            "/opt",     // Optional packages
            "/var/www", // Web server files
        ],
        deep_scan,
    )
    .await
}

/// Check executables against malware hash database (deep mode - full system)
pub async fn check_malware_hashes(deep_scan: bool) -> Result<Vec<Finding>> {
    check_malware_hashes_with_paths(
        &[
            "/bin",
            "/sbin",
            "/usr/bin",
            "/usr/sbin",
            "/usr/local/bin",
            "/usr/local/sbin",
            "/lib",     // Shared libraries
            "/usr/lib", // User libraries
            "/opt",     // Optional packages
            "/tmp",     // Temporary files (high risk)
            "/var/tmp", // Persistent temp (high risk)
            "/dev/shm", // Shared memory (high risk)
            "/var/www", // Web server files
            "/srv",     // Service data
            "/home",    // All user home directories
            "/root",    // Root user home
        ],
        deep_scan,
    )
    .await
}

/// Internal function to check malware hashes for specified paths
async fn check_malware_hashes_with_paths(
    scan_paths: &[&str],
    deep_scan: bool,
) -> Result<Vec<Finding>> {
    if deep_scan {
        info!("🔍 Checking executables against malware hash database (DEEP SCAN - ALL FILES)...");
    } else {
        info!("🔍 Checking executables against malware hash database...");
    }
    let mut findings = Vec::new();

    // Get malware hash database (download or use cache)
    let hash_db = match get_hash_database().await {
        Ok(db) => db,
        Err(e) => {
            warn!(
                "Failed to load malware hash database: {}. Skipping hash checks.",
                e
            );
            return Ok(findings);
        }
    };

    info!(
        "  Loaded {} malware hashes, scanning {} locations",
        hash_db.total_count,
        scan_paths.len()
    );

    for path in scan_paths {
        if let Ok(scan_findings) = scan_directory_for_malware(path, &hash_db, deep_scan).await {
            findings.extend(scan_findings);
        }
    }

    info!("  Found {} malware hash matches", findings.len());
    Ok(findings)
}

/// Get malware hash database (download if needed, use cache if recent)
async fn get_hash_database() -> Result<MalwareHashDatabase> {
    let cache_path = get_cache_path();

    // Check if cache exists and is recent (< 7 days old)
    if let Ok(metadata) = fs::metadata(&cache_path) {
        if let Ok(modified) = metadata.modified() {
            let age = std::time::SystemTime::now()
                .duration_since(modified)
                .unwrap_or_default();

            // Use cache if less than 7 days old
            if age.as_secs() < 7 * 24 * 3600 {
                debug!("Using cached malware hash database");
                if let Ok(db) = load_from_cache(&cache_path) {
                    return Ok(db);
                }
            }
        }
    }

    // Download fresh database
    info!("Downloading malware hash database from MalwareBazaar...");
    download_hash_database().await
}

/// Download malware hash database from MalwareBazaar
async fn download_hash_database() -> Result<MalwareHashDatabase> {
    // Get cache directory (handles root vs user)
    let cache_dir = get_cache_dir();

    if !cache_dir.exists() {
        fs::create_dir_all(&cache_dir).with_context(|| {
            format!("Failed to create cache directory: {}", cache_dir.display())
        })?;
    }

    let cache_path = get_cache_path();
    let zip_path = cache_dir.join("malware_hashes.zip");

    // Download ZIP file using curl
    info!("Downloading malware hash database from MalwareBazaar (this may take 1-2 minutes)...");
    let output = Command::new("curl")
        .args([
            "-s",
            "-L",
            "-o",
            zip_path.to_str().unwrap(),
            MALWARE_BAZAAR_URL,
        ])
        .output()
        .context("Failed to execute curl (is it installed?)")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("curl failed: {}", stderr);
    }

    // Check if file was actually downloaded
    if !zip_path.exists() || fs::metadata(&zip_path)?.len() < 1000 {
        anyhow::bail!("Downloaded file is missing or too small");
    }

    // Extract the CSV file from the ZIP
    info!("Extracting hash database...");
    let extract_output = Command::new("unzip")
        .args([
            "-o", // Overwrite existing
            "-j", // Don't create directories
            zip_path.to_str().unwrap(),
            "-d",
            cache_dir.to_str().unwrap(),
        ])
        .output()
        .context("Failed to execute unzip (is it installed?)")?;

    if !extract_output.status.success() {
        anyhow::bail!("Failed to extract malware hash database");
    }

    // Rename full.csv to malware_hashes.csv
    let extracted_csv = cache_dir.join("full.csv");
    if extracted_csv.exists() {
        fs::rename(&extracted_csv, &cache_path)?;
    }

    // Clean up ZIP file
    let _ = fs::remove_file(&zip_path);

    info!("✅ Malware hash database downloaded successfully");

    // Parse the downloaded CSV
    load_from_cache(&cache_path)
}

/// Load malware hash database from cache
fn load_from_cache(cache_path: &Path) -> Result<MalwareHashDatabase> {
    let content =
        fs::read_to_string(cache_path).context("Failed to read malware hash database cache")?;

    let mut sha256_hashes = HashSet::new();
    let mut total_count = 0;

    // Parse CSV (skip comments and header)
    for line in content.lines() {
        // Skip comment lines
        if line.trim().starts_with('#') || line.trim().is_empty() {
            continue;
        }

        // CSV format: "first_seen", "sha256_hash", "md5_hash", ...
        // Fields are quoted and comma-separated
        // SHA256 is the second field (index 1)

        // Simple CSV parsing: split by ", " to handle quoted fields
        let line = line.trim_matches('"');
        let fields: Vec<&str> = line.split("\", \"").collect();

        if fields.len() < 2 {
            continue;
        }

        // Extract SHA256 hash (field 1) and remove quotes
        let sha256 = fields[1].trim().trim_matches('"').to_lowercase();
        if !sha256.is_empty() && sha256.len() == 64 {
            sha256_hashes.insert(sha256);
            total_count += 1;
        }
    }

    Ok(MalwareHashDatabase {
        sha256_hashes,
        total_count,
    })
}

/// Scan directory for malware by hash
async fn scan_directory_for_malware(
    path: &str,
    hash_db: &MalwareHashDatabase,
    deep_scan: bool,
) -> Result<Vec<Finding>> {
    let mut findings = Vec::new();

    let path_buf = PathBuf::from(path);
    if !path_buf.exists() {
        return Ok(findings);
    }

    // Build find command args dynamically for better performance
    let find_args = vec![
        path.to_string(),
        "-type".to_string(),
        "f".to_string(),
        "(".to_string(),
        "-executable".to_string(),
        "-o".to_string(),
        "-name".to_string(),
        "*.so".to_string(),
        "-o".to_string(),
        "-name".to_string(),
        "*.so.*".to_string(),
        ")".to_string(),
        "-print0".to_string(), // Use null delimiter for better handling
    ];

    // Use find to get all executable files
    let output = Command::new("find").args(&find_args).output();

    if output.is_err() {
        return Ok(findings);
    }

    let output = output.unwrap();

    // Split by null character for better handling of filenames with spaces
    let files: Vec<&str> = output
        .stdout
        .split(|&b| b == 0)
        .filter_map(|bytes| std::str::from_utf8(bytes).ok())
        .filter(|s| !s.trim().is_empty())
        .collect();

    if files.is_empty() {
        return Ok(findings);
    }

    // Filter files: skip obviously safe files and directories (unless deep_scan is enabled)
    let filtered_files: Vec<&&str> = if deep_scan {
        // Deep scan: scan ALL files
        files.iter().collect()
    } else {
        // Normal scan: apply smart filtering
        files
            .iter()
            .filter(|file_path| should_scan_file(file_path))
            .collect()
    };

    if deep_scan {
        debug!(
            "  Scanning {} files in {} (DEEP SCAN - no filtering)",
            filtered_files.len(),
            path
        );
    } else {
        debug!(
            "  Scanning {} files in {} (filtered from {})",
            filtered_files.len(),
            path,
            files.len()
        );
    }

    // Check each file's hash
    for file_path in filtered_files {
        // Skip files that are too large (>100MB unlikely to be malware binaries)
        // Even in deep scan mode, skip extremely large files
        if !deep_scan {
            if let Ok(metadata) = fs::metadata(file_path) {
                if metadata.len() > MAX_FILE_SIZE {
                    debug!(
                        "  Skipping large file: {} ({} MB)",
                        file_path,
                        metadata.len() / 1_048_576
                    );
                    continue;
                }
            }
        }

        if let Ok(hash) = calculate_sha256(file_path) {
            if hash_db.sha256_hashes.contains(&hash) {
                findings.push(
                    Finding::critical(
                        "malware_hash_match",
                        "Known Malware Detected by Hash",
                        &format!(
                            "File '{}' matches known malware hash (SHA256: {}). System is compromised!",
                            file_path,
                            &hash[..16]
                        ),
                    )
                    .with_remediation(&format!(
                        "Remove immediately: sudo rm -f '{}' && investigate how it got there",
                        file_path
                    )),
                );
            }
        }
    }

    Ok(findings)
}

/// Check if a file should be scanned (filter out obviously safe files)
fn should_scan_file(file_path: &str) -> bool {
    let path_lower = file_path.to_lowercase();

    // Skip common safe directories
    let skip_dirs = [
        "/.git/",
        "/node_modules/",
        "/.cache/",
        "/.local/share/",
        "/.cargo/",
        "/.rustup/",
        "/venv/",
        "/__pycache__/",
        "/.npm/",
        "/.gradle/",
        "/.m2/",
        "/target/debug/",
        "/target/release/",
    ];

    for skip_dir in &skip_dirs {
        if path_lower.contains(skip_dir) {
            return false;
        }
    }

    // Skip common non-executable extensions
    let skip_extensions = [
        ".txt", ".log", ".md", ".json", ".xml", ".yaml", ".yml", ".conf", ".cfg", ".jpg", ".jpeg",
        ".png", ".gif", ".bmp", ".svg", ".ico", ".mp3", ".mp4", ".avi", ".mkv", ".mov", ".flv",
        ".wav", ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".zip", ".tar", ".gz",
        ".bz2", ".xz", ".7z", ".rar", ".css", ".scss", ".less", ".html", ".htm", ".o", ".a",
        ".pyc", ".class",
    ];

    for ext in &skip_extensions {
        if path_lower.ends_with(ext) {
            return false;
        }
    }

    true
}

/// Calculate SHA256 hash of a file (native Rust implementation - much faster!)
fn calculate_sha256(file_path: &str) -> Result<String> {
    let mut file =
        fs::File::open(file_path).with_context(|| format!("Failed to open file: {}", file_path))?;

    let mut hasher = Sha256::new();
    let mut buffer = [0u8; 8192]; // 8KB buffer

    loop {
        let bytes_read = file.read(&mut buffer)?;
        if bytes_read == 0 {
            break;
        }
        hasher.update(&buffer[..bytes_read]);
    }

    let hash = hasher.finalize();
    Ok(format!("{:x}", hash))
}

/// Get cache directory (root uses /var/cache, users use ~/.cache)
fn get_cache_dir() -> PathBuf {
    if std::env::var("USER").unwrap_or_default() == "root" {
        PathBuf::from(CACHE_DIR)
    } else {
        let home = std::env::var("HOME").unwrap_or_else(|_| "/tmp".to_string());
        PathBuf::from(home).join(".cache/linux-guardian")
    }
}

/// Get cache file path
fn get_cache_path() -> PathBuf {
    get_cache_dir().join(HASH_DB_FILE)
}

/// Update malware hash database (called with --update-malware-db)
pub async fn update_malware_database() -> Result<()> {
    info!("Updating malware hash database...");

    let db = download_hash_database().await?;

    info!(
        "✅ Malware hash database updated successfully: {} hashes",
        db.total_count
    );

    Ok(())
}

/// Show malware hash database statistics
pub async fn show_malware_db_stats() -> Result<()> {
    let cache_path = get_cache_path();

    if !cache_path.exists() {
        println!("Malware hash database not found. Run with --update-malware-db to download.");
        return Ok(());
    }

    let db = load_from_cache(&cache_path)?;
    let metadata = fs::metadata(&cache_path)?;
    let modified = metadata.modified()?;
    let age = std::time::SystemTime::now()
        .duration_since(modified)
        .unwrap_or_default();

    println!("Malware Hash Database Statistics:");
    println!("══════════════════════════════════");
    println!("  Total hashes: {}", db.total_count);
    println!("  Cache age: {:.1} days", age.as_secs() as f64 / 86400.0);
    println!("  Cache file: {}", cache_path.display());
    println!("  Source: MalwareBazaar (abuse.ch)");
    println!();

    if age.as_secs() > 7 * 24 * 3600 {
        println!("⚠️  Database is older than 7 days. Consider updating with --update-malware-db");
    } else {
        println!("✅ Database is up to date");
    }

    Ok(())
}
